"use client";

import React, {
  useState,
  useEffect,
  useRef,
  useCallback,
  useMemo,
} from "react";
import { getCastShadowsImageUrl, getCastShadowsImageUrlWithFallback } from "../lib/models-config";

interface CastShadowsSequenceProps {
  className?: string;
  width?: number;
  height?: number;
  autoPlay?: boolean;
  startAnimation?: boolean; // New prop to control when animation starts
  scrollProgress?: number; // 0 to 1 based on scroll position - when provided, overrides autoPlay
  loop?: boolean;
  duration?: number; // Duration in seconds instead of FPS
  fps?: number; // Keep FPS as fallback
  onSequenceComplete?: () => void;
  priority?: boolean;
}

export default function CastShadowsSequence({
  className = "",
  autoPlay = true,
  startAnimation = false,
  scrollProgress,
  loop = true,
  duration = 35,
  fps = 30,
  onSequenceComplete,
}: CastShadowsSequenceProps) {

  
  const [currentFrame, setCurrentFrame] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isReady, setIsReady] = useState(false);
  const [loadingComplete, setLoadingComplete] = useState(false);
  const [firstFrameLoaded, setFirstFrameLoaded] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Image cache for smooth playback - environment-optimized
  const imageCache = useRef<Map<number, HTMLImageElement>>(new Map());
  const preloadQueue = useRef<Set<number>>(new Set());
  const isPreloading = useRef(false);
  
  // CDN-optimized performance settings for consistent global performance
  const PRELOAD_BUFFER = 6; // Optimized buffer for CDN loading
  const MAX_CACHE_SIZE = 15; // Balanced cache size for CDN images

  // Generate array of image paths for CAST SHADOWS using configuration
  const totalFrames = 1200;

  const imagePaths = useMemo(() => {
    const paths: string[] = [];
    for (let i = 1; i <= totalFrames; i++) {
      const frameNumber = i.toString().padStart(4, "0");
      const filename = `CAST SHADOWS${frameNumber}.avif`;
      const url = getCastShadowsImageUrl(filename);
      paths.push(url);
    }

    return paths;
  }, [totalFrames]);

  // Optimized FPS for smooth playback
  const effectiveFPS = useMemo(() => {
    if (duration) {
      // For scroll-driven mode, use full frame rate for smooth animation
      return totalFrames / duration;
    }
    // Use original FPS for autoplay, but cap at reasonable limit
    return Math.min(fps, 30);
  }, [totalFrames, duration, fps]);

  const updateProgress = useCallback(
    (loadedCount: number) => {
      if (loadedCount === totalFrames) {
        setIsReady(true);
        setLoadingComplete(true);
      }
    },
    [totalFrames]
  );

  // Conservative preloading for large AVIF files
  const preloadFrame = useCallback((frameIndex: number) => {
    if (frameIndex < 0 || frameIndex >= totalFrames) return;
    if (imageCache.current.has(frameIndex) || preloadQueue.current.has(frameIndex)) return;
    if (preloadQueue.current.size >= 1) return; // Very conservative concurrent preloads for performance
    
    preloadQueue.current.add(frameIndex);
    
    const img = new window.Image();
    
    // Add timeout to prevent hanging on large files
    const timeout = setTimeout(() => {
      preloadQueue.current.delete(frameIndex);
      img.src = ''; // Cancel loading
    }, 10000); // 10 second timeout
    
    img.onload = () => {
      clearTimeout(timeout);
      imageCache.current.set(frameIndex, img);
      preloadQueue.current.delete(frameIndex);
    };
    img.onerror = () => {
      clearTimeout(timeout);
      preloadQueue.current.delete(frameIndex);
      
      // Retry logic: try to load from CDN as fallback
      const retryImg = new Image();
      const filename = `CAST SHADOWS${(frameIndex + 1).toString().padStart(4, '0')}.avif`;
      const fallbackUrls = getCastShadowsImageUrlWithFallback(filename);
      
      retryImg.onload = () => {
        imageCache.current.set(frameIndex, retryImg);
        // Silently use CDN fallback
      };
      
      retryImg.onerror = () => {
        console.warn(`Failed to load cast shadow frame ${frameIndex} (both local and CDN)`);
      };
      
      retryImg.src = fallbackUrls.fallback;
    };
    img.src = imagePaths[frameIndex];
  }, [imagePaths, totalFrames]);

  // CDN-optimized preloading throttle
  const lastPreloadTime = useRef(0);
  const PRELOAD_THROTTLE = 100; // Optimized throttle for CDN loading
  
  const preloadAroundFrame = useCallback((centerFrame: number) => {
    const now = Date.now();
    if (isPreloading.current || (now - lastPreloadTime.current) < PRELOAD_THROTTLE) return;
    
    isPreloading.current = true;
    lastPreloadTime.current = now;
    
    // Prioritize current frame and next few frames for scroll direction
    preloadFrame(centerFrame);
    preloadFrame(centerFrame + 1);
    preloadFrame(centerFrame + 2);
    
    // Use requestIdleCallback or setTimeout for additional frames
    const scheduleBufferLoad = () => {
      for (let i = 3; i <= PRELOAD_BUFFER; i++) {
        preloadFrame(centerFrame + i); // Ahead only (scroll direction)
      }
      // Load behind frames with lower priority
      setTimeout(() => {
        for (let i = 1; i <= 2; i++) {
          preloadFrame(centerFrame - i);
        }
      }, 100);
    };
    
    if (window.requestIdleCallback) {
      window.requestIdleCallback(scheduleBufferLoad, { timeout: 50 });
    } else {
      setTimeout(scheduleBufferLoad, 16);
    }
    
    // More aggressive cache cleanup for performance
    const cacheEntries = Array.from(imageCache.current.entries());
    
    // If cache is too large, remove farthest frames immediately
    if (cacheEntries.length > MAX_CACHE_SIZE) {
      // Sort by distance from current frame
      cacheEntries.sort((a, b) => Math.abs(a[0] - centerFrame) - Math.abs(b[0] - centerFrame));
      
      // Remove the farthest frames aggressively
      const framesToRemove = cacheEntries.length - Math.floor(MAX_CACHE_SIZE * 0.75);
      for (let i = MAX_CACHE_SIZE; i < cacheEntries.length && i < MAX_CACHE_SIZE + framesToRemove; i++) {
        imageCache.current.delete(cacheEntries[i][0]);
      }
    }
    
    // Remove frames that are far from current position
    for (const [frameIndex] of imageCache.current) {
      if (Math.abs(frameIndex - centerFrame) > PRELOAD_BUFFER * 1.5) {
        imageCache.current.delete(frameIndex);
      }
    }
    
    isPreloading.current = false;
  }, [preloadFrame, PRELOAD_BUFFER]);

  // Intersection observer for performance - only preload when visible
  const [isVisible, setIsVisible] = useState(true); // Always start visible for immediate loading
  
  useEffect(() => {
    // For scroll-driven mode, always consider visible
    if (typeof scrollProgress === 'number') {
      setIsVisible(true);
      return;
    }
    
    if (!containerRef.current) return;
    
    const observer = new IntersectionObserver(
      ([entry]) => {
        setIsVisible(entry.isIntersecting);
      },
      { 
        threshold: 0.1,
        rootMargin: '50px' // Start loading slightly before visible
      }
    );
    
    observer.observe(containerRef.current);
    
    return () => {
      observer.disconnect();
    };
  }, [scrollProgress]);

  // Synchronous first frame loading to eliminate black frames
  useEffect(() => {
    if (imagePaths.length === 0) return;
    
    // Load first frame synchronously and wait for it
    const firstImg = new Image();
    firstImg.onload = () => {
      imageCache.current.set(0, firstImg);
      setFirstFrameLoaded(true);
      setIsReady(true);
      
      // Now preload additional frames
      const initialFrames = Math.min(15, totalFrames);
      for (let i = 1; i < initialFrames; i++) {
        preloadFrame(i);
      }
      
      // Load more frames when visible
      if (isVisible) {
        setTimeout(() => {
          for (let i = initialFrames; i < Math.min(30, totalFrames); i++) {
            preloadFrame(i);
          }
        }, 8); // Very fast follow-up
      }
    };
    
    firstImg.onerror = () => {
      console.error('Failed to load first frame, trying HQ version');
      // Try loading from high-quality folder as fallback
      const hqFirstImg = new Image();
      hqFirstImg.onload = () => {
        imageCache.current.set(0, hqFirstImg);
        setFirstFrameLoaded(true);
        setIsReady(true);
      };
      hqFirstImg.onerror = () => {
        console.error('Failed to load first frame from both optimized and HQ folders');
        // Still set as ready to prevent blocking, but log error
        setFirstFrameLoaded(true);
        setIsReady(true);
      };
      hqFirstImg.src = `/cast-shadows-hq/${encodeURIComponent('CAST SHADOWS0001.avif')}`;
    };
    
    firstImg.src = imagePaths[0];
  }, [imagePaths, preloadFrame, isVisible, totalFrames]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      // Clear all cached images
      imageCache.current.clear();
      preloadQueue.current.clear();
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, []);

  // Animation logic - use scroll progress if provided, otherwise use auto-play
  const isScrollDriven = typeof scrollProgress === "number";

  // Debounced scroll handling for large files
  const scrollDebounceRef = useRef<NodeJS.Timeout>();
  const lastScrollFrame = useRef(-1);
  
  const calculateCurrentFrame = () => {
    if (isScrollDriven) {
      // Direct linear mapping with optional frame skipping for performance
      let frame = Math.floor(scrollProgress! * (totalFrames - 1));
      
      // Skip frames if scrolling very fast to improve performance
      const frameDiff = Math.abs(frame - (lastScrollFrame.current || 0));
      if (frameDiff > 10) {
        // Large jumps - use every 2nd frame to reduce load
        frame = Math.floor(frame / 2) * 2;
      }
      
      const clampedFrame = Math.max(0, Math.min(frame, totalFrames - 1));
      
      // Debounce preloading to avoid overwhelming browser with large files
      if (clampedFrame !== lastScrollFrame.current) {
        lastScrollFrame.current = clampedFrame;
        
        if (scrollDebounceRef.current) {
          clearTimeout(scrollDebounceRef.current);
        }
        
        scrollDebounceRef.current = setTimeout(() => {
          preloadAroundFrame(clampedFrame);
        }, 32); // Balanced debounce for performance
      }
      
      return clampedFrame;
    }
    return currentFrame; // Auto-play mode
  };

  const displayFrame = calculateCurrentFrame();



  useEffect(() => {
    if (isScrollDriven) return;

    if (!isReady || !loadingComplete || !startAnimation) return;

    if (autoPlay) {
      setIsPlaying(true);
    }
  }, [isReady, loadingComplete, startAnimation, autoPlay, isScrollDriven]);

  const animationFrameRef = useRef<number | null>(null);
  const lastUpdateTimeRef = useRef<number>(0);

  const animate = useCallback(() => {
    if (!isPlaying) return;

    const now = performance.now();
    const deltaTime = now - lastUpdateTimeRef.current;
    const frameInterval = 1000 / effectiveFPS;

    if (deltaTime >= frameInterval) {
      setCurrentFrame((prevFrame) => {
        const nextFrame = prevFrame + 1;
        
        // Preload frames around next frame for smooth auto-play
        preloadAroundFrame(nextFrame);
        
        if (nextFrame >= totalFrames) {
          if (loop) {
            preloadAroundFrame(0); // Preload start frames for loop
            return 0;
          } else {
            setIsPlaying(false);
            if (onSequenceComplete) {
              onSequenceComplete();
            }
            return prevFrame;
          }
        }
        return nextFrame;
      });

      lastUpdateTimeRef.current = now - (deltaTime % frameInterval);
    }

    animationFrameRef.current = requestAnimationFrame(animate);
  }, [isPlaying, effectiveFPS, totalFrames, loop, onSequenceComplete, preloadAroundFrame]);

  useEffect(() => {
    if (isPlaying) {
      lastUpdateTimeRef.current = performance.now();
      animationFrameRef.current = requestAnimationFrame(animate);
    } else {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
    }

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [isPlaying, animate]);

  // Get current image from cache or fallback to URL
  const currentImageSrc = (() => {
    if (!imagePaths || imagePaths.length === 0) {
      return ''; // Return empty string if no images loaded yet
    }
    
    const safeFrame = Math.max(0, Math.min(displayFrame, imagePaths.length - 1));
    
    // Use cached image if available, otherwise use URL (browser cache)
    const cachedImage = imageCache.current.get(safeFrame);
    if (cachedImage && cachedImage.complete && cachedImage.naturalWidth > 0) {
      return cachedImage.src;
    }
    
    // Enhanced fallback strategy to prevent black frames
    // Try previous frames first (going backwards)
    for (let i = safeFrame - 1; i >= Math.max(0, safeFrame - 3); i--) {
      const fallbackImage = imageCache.current.get(i);
      if (fallbackImage && fallbackImage.complete && fallbackImage.naturalWidth > 0) {
        return fallbackImage.src;
      }
    }
    
    // Try next frames (going forwards)
    for (let i = safeFrame + 1; i <= Math.min(imagePaths.length - 1, safeFrame + 3); i++) {
      const fallbackImage = imageCache.current.get(i);
      if (fallbackImage && fallbackImage.complete && fallbackImage.naturalWidth > 0) {
        return fallbackImage.src;
      }
    }
    
    // Always try frame 0 as ultimate fallback
    const firstFrameImage = imageCache.current.get(0);
    if (firstFrameImage && firstFrameImage.complete && firstFrameImage.naturalWidth > 0) {
      return firstFrameImage.src;
    }
    
    // If first frame is loaded but we can't find current frame, always use first frame
    if (firstFrameLoaded && imageCache.current.has(0)) {
      return imageCache.current.get(0)!.src;
    }
    
    // Last resort: use direct URL only if first frame is loaded
    if (firstFrameLoaded) {
      const imageSrc = imagePaths[safeFrame] || imagePaths[0];
      return imageSrc || '';
    }
    
    // Don't return anything until first frame is loaded
    return '';
  })();

  return (
    <div
      ref={containerRef}
      className={`cast-shadows-sequence ${className}`}
      style={{
        width: "100%",
        height: "100%",
        position: "relative",
        overflow: "hidden",
        transform: "translate3d(0, 0, 0)", // Force GPU layer with 3D transform
        willChange: "contents", // Optimize for changing content
        backfaceVisibility: "hidden",
        containIntrinsicSize: "100% 100%", // Help with layout performance
        contentVisibility: "auto", // Optimize rendering
      }}
    >
      {/* Main Image Display */}
      <div className="relative w-full h-full">
        {firstFrameLoaded && currentImageSrc ? (
          <img
            src={currentImageSrc}
            alt=""
            loading="eager"
            decoding="sync" // Use sync for immediate display
            fetchPriority="high"
            style={{
              width: "100%",
              height: "100%",
              display: "block",
              objectFit: "cover",
              transform: "translate3d(0, 0, 0)", // Force hardware acceleration
              backfaceVisibility: "hidden",
              imageRendering: "auto", // Let browser optimize
              willChange: "transform", // Hint for optimization
            }}
          />
        ) : (
          // Show a transparent placeholder until first frame loads
          <div 
            style={{
              width: "100%",
              height: "100%",
              backgroundColor: "transparent",
            }}
          />
        )}
      </div>
    </div>
  );
}
